# R21-11 Explanation of Platform Design
## 変更点
* RESTが削除  
* IDSMの紹介が追加  
* SHMの紹介がPHMのチャプターで追加  
* Persistencyの章を修正  
* UCMとSMの関連について修正  
* EM,Diag,TSyncのマイナーアップデート  

## 3 Technical Scope and Approach
### 3.1 Overview - a landscape of intelligent ECUs
従来、ECUは主に、電気機械システムを置き換えたり増強したりする機能を実装しています。これらの深く組み込まれたECUのソフトウェアは、  
車両ネットワークに接続された他のECUからの入力信号と情報に基づいて電気出力信号を制御します。  
制御ソフトウェアの多くは、対象車両用に設計および実装されており、車両の寿命中に大幅に変更されることはありません。
高度に自動化された運転などのいくつかの車両機能は、非常に複雑でコンピューティングリソースを要求するソフトウェアを車両に導入し、厳格な整合性とセキュリティ要件を満たす必要があります。  
このようなソフトウェアは、環境認識や行動計画などの機能を実現し、車両を外部のバックエンドおよびインフラストラクチャシステムに統合します。  
車両のソフトウェアは、外部システムの進化や機能の向上により、車両のライフサイクル中に更新する必要があります。  
  
AUTOSAR Classic Platform（CP）規格は、深く組み込まれたECUのニーズに対応していますが、  
上記のECUのニーズを満たすことはできません。  
したがって、AUTOSARは、2番目のソフトウェアプラットフォームであるAUTOSAR Adaptive Platform（AP）を指定します。  
APは、主に高性能コンピューティングおよび通信メカニズムを提供し、柔軟なソフトウェア構成を提供します。  
無線でのソフトウェアアップデートをサポートします。電気信号や自動車固有のバスシステムへのアクセスなど、  
CP用に特別に定義された機能は、APに統合できますが、標準化の焦点にはなりません。  

> 自動運転などの複雑なソフトウェアを導入するためにリソースへの要求は高まり、外部との通信(OTAなど)  
> によってソフトウェアの更新をかける必要も出てきた。  
> 上記の文に書いてあるように、CPでは対応できない、高性能コンピューティングおよび通信メカニズムを提供し、  
> 柔軟なソフトウェア構成を提供するといった点がAPの役割。

### 3.2 Technology Drivers
背後にあるテクノロジードライバーの2つの主要なグループがあります。  
1つはイーサネットで、もう1つはプロセッサです。  

車載ネットワークのますます増大する帯域幅要件により、イーサネットが導入されました。  
イーサネットは、より高い帯域幅を提供し、ネットワークを切り替えて、長いメッセージのより効率的な転送、  
ポイントツーポイント通信などを可能にします。  
CANなどの従来の車載通信技術と比較して。 CPはイーサネットをサポートしていますが、  
主にレガシー通信テクノロジー向けに設計されており、そのために最適化されており、  
イーサネットベースの通信機能を十分に活用してメリットを得るのは困難です。  

> EthernetとはTCP/IPに対応した有線の規格のこと。
> LANケーブルはEthernet規格のケーブル。従来の車両通信で用いられていたプロトコルはCANやLINなど。
> CANやLINだと大容量データなどの通信には不向きな印象。
> 通信速度は10Mbps。
> CANは一回に送信できるデータは8バイト。通信速度は最大1Mbps。
> 以下サイトをみるとEthernetとは、なぜ車載に必要なのかがまとめられている。
> https://monoist.itmedia.co.jp/mn/articles/1905/13/news008.html

同様に、車両がさらにインテリジェントになるにつれて、  
プロセッサのパフォーマンス要件は近年非常に大きくなっています。  
マルチコアプロセッサはすでにCPで使用されていますが、処理能力のニーズにはマルチコア以上のものが必要です。  
数十から数百のコアを備えたメニーコアプロセッサ、GPGPU（GPUの汎用使用）、FPGA、および専用アクセラレータが登場しています。  
これらは、従来のMCUよりも桁違いに高いパフォーマンスを提供するためです。

> メニーコアはめちゃくちゃいっぱいプロセッサがあるCPUっていう大雑把な理解でOK
> https://wa3.i-3-i.info/word18085.html

コア数の増加は、マルチコアをサポートできますが、元々シングルコアMCU用に設計されたCPの設計を圧倒します。 
また、コンピューティング能力が高まるにつれ、データセンターでも電力効率がすでに問題になっています。  
実際、これらのインテリジェントECUにとってははるかに重要です。  
半導体およびプロセッサテクノロジの観点からは、ポラックの法則に制約されるため、  
プロセッサの周波数を際限なく上げることは物理的に不可能であり、パフォーマンスを拡張する唯一の方法は、  
複数（および多数）のコアを使用して並列に実行することです。  
また、ワットあたりの最高のパフォーマンスは、メニーコア、コプロセッサー、GPU、FPGA、  
アクセラレーターなどのさまざまなコンピューティングリソースを組み合わせることで達成されることが知られています。  
これはヘテロジニアスコンピューティングと呼ばれ、現在HPC（ハイパフォーマンスコンピューティング）で活用されていますが、  
CPの範囲をはるかに圧倒しています。

また、プロセッサとより高速な通信の両方の複合効果があることにも言及する価値があります。  
メニーコアプロセッサのように、より多くの処理要素が1つのチップに統合されるにつれて、  
これらの処理要素間の通信は、従来のECU間通信よりも桁違いに高速かつ効率的になります。  
これは、Network-on-Chip（NoC）などの新しいタイプのプロセッサ相互接続テクノロジによって可能になりました。  
より多くの処理能力とチップ内のより高速な通信のこのような複合効果はまた、  
増え続けるシステム要件を拡張できる新しいプラットフォームの必要性を促します。

### 3.3 Adaptive Platform - Characteristics

## 8 Communication Management
### 8.1 Overview
CMは、分散リアルタイム組み込み環境でのアプリケーション間の通信のすべての側面を担当します。  
背後にある概念は、アプリケーションソフトウェアの実装者がアプリケーションの特定の目的に集中できるように、実際のメカニズムから抽象化して通信パートナーを見つけて接続することです。  

### 8.2 Service Oriented Communication
サービスの概念は、基本的なオペレーティングソフトウェアによってすでに提供されている機能を超えてアプリケーションに提供される機能を意味します。  
CMソフトウェアは、マシン内通信およびマシン間通信のためにそのようなサービスを提供または利用するためのメカニズムを提供します。
サービスは以下の組み合わせで構成される。  
* Events  
* Methods  
* Fields 
通信パートナー間の通信パスは、設計時、起動時、または実行時に確立できます。  
このメカニズムの重要なコンポーネントは、ブローカリングインスタンスとして機能し、CommunicationManagementソフトウェアの一部でもあるサービスレジストリです。  
![](./img/Figure8.1)


サービスを提供する各アプリケーションは、サービスレジストリでこれらのサービスを登録します。  
アプリケーションがサービスを使用するには、サービスレジストリにクエリを実行して、要求されたサービスを見つける必要があります。このプロセスは、Service Discoveryと呼ばれます。  

> サービス志向通信を実現するために機構を提供してくれている。

### 8.3 Language binding and Network binding
Communication Managementは、定義されたサービスがアプリケーション実装者にどのように提示されるか（上位層、言語バインディング）、およびネットワーク上のサービスのデータのそれぞれの表現（下位層、ネットワークバインディング）を標準化した手段で提供します。
これにより、プラットフォームのさまざまな実装間でのソースコードの移植性とコンパイル済みサービスの互換性が保証されます。  

言語バインディングは、対象のプログラミング言語の便利な機能を使用して、サービスのメソッド、イベント、およびフィールドを直接アクセス可能な識別子に変換する方法を定義します。  
パフォーマンスと型の安全性（ターゲット言語でサポートされている限り）が主な目標です。  
したがって、言語バインディングは通常、サービスインターフェイス定義によって供給されるソースコードジェネレーターによって実装されます。  

> 言語バインディングの機能はコンフィグの時点で設定できるってこと？  
> ソースコードジェネレーターとはara-genや、AUBIST configuratorなどのコード生成ツールのことをおそらく指している。arxmlで設定された内容は、jsonファイルや、cpp,hppなどの実装として吐き出される。各サービス内容はcppファイルで自動生成されるはず。

![](./img/Figure8.2.png)

ネットワークバインディングは、構成されたサービスの実際のデータをシリアル化して特定のネットワークにバインドする方法を定義します。  
生成されたサービス固有のレシピを解釈するか、シリアル化コード自体を直接生成することにより、Communication Management構成（AUTOSARメタモデルのインターフェイス定義）に基づいて実装できます。  
現在、Communication Managementは、SOME / IP、DDS、IPC（プロセス間通信またはその他のカスタムバインディング）、Signal PDU（信号ベースのネットワークバインディング）、および信号ベースの静的ネットワークバインディングをサポートしています。  
ローカルサービスレジストリもネットワークバインディングの一部です。  

注意：LanguageBindingとNetworkBindingの間のインターフェースは、CommunicationManagementソフトウェア内のプライベートインターフェースと見なされます。  
したがって、このインターフェースを定義する規範的な仕様は現在範囲外です。  
それでも、プラットフォームベンダーは、プラットフォーム実装内の他のネットワークバインディングと一緒にC ++以外の言語バインディングを簡単に実装できるように、ソフトウェア用にこのようなインターフェイスを個別に定義することをお勧めします。  

> Language bindingとNetwork bindingよう分からん。
> 後でSWS読んでおく。
> 多分Service IFジェネレートするときにcppとかpythonでジェネレート時に選択できるってのと、使用するプロトコルを選択できるって感じなのかなぁ(SOME/IP,DDSなど)

> CMの機能としては、以下
> * SOA通信メカニズム提供
> * Network binding
> * Language binding
> * Raw Data Streaming Interface

### 8.4 Generated Proxies and Skeletons of C++ Language Binding
C ++言語バインディングの上位層インターフェースは、AUTOSARメタモデルのインターフェース記述で定義されたサービスのオブジェクト指向マッピングを提供します。  

Communication Managementソフトウェアの開発ツールの一部であるジェネレーターは、それぞれのサービスのフィールド、イベント、およびメソッドのタイプセーフな表現を含むC ++クラスを生成します。  

サービス実装側では、これらの生成されたクラスはサービスプロバイダースケルトンと呼ばれます。  
クライアント側では、これらはサービスリクエスタープロキシと呼ばれます。  

> サービス利用側に生成されたクラスー＞プロキシ  
> 提供側はスケルトン

サービスメソッドの場合、サービスリクエスタープロキシは、同期（サーバーが結果を返すまで呼び出し元をブロックする）および非同期呼び出し（呼び出された関数がすぐに戻る）のメカニズムを提供します。 

> 同期通信は、レスポンスが来るまで処理を止める。非同期はリクエストだけ出して処理を継続する。

呼び出し元は他のアクティビティを並行して開始でき、サーバーの戻り値がコアタイプara :: core :: Futureの特別な機能を介して利用可能になったときに結果を受け取ります（セクション18.1.4を参照）。  

プラットフォームの実装は、それぞれのサーバーがまだ利用できない場合に、ジェネレーターがクライアント機能の開発を容易にするためのモックアップクラスを作成するように構成できます。  
同じメカニズムをクライアントの単体テストにも使用できます。  

プロキシクラスはクライアントが直接使用できますが、C ++バインディングのサービスプロバイダースケルトンは単なる抽象基本クラスです。  
サービスの実装は、生成された基本クラスから派生し、それぞれの機能を実装する必要があります。  

> ジェネレートされるのはあくまで抽象クラスなので、スケルトン側の実装は開発者がしなければならない。多分、offerServiceとかの実装のこと指してるのかな…。  

ara :: comのインターフェースは、安全関連のE2E保護通信用のプロキシとスケルトンも提供できます。  
これらのインターフェイスは、E2E保護がオンまたはオフに切り替えられているかどうかに関係なく、アプリケーションとの互換性が保証されるように設計されています。  

### 8.5 Static and dynamic configuration
通信パスの構成は、設計時、起動時、または実行時に発生する可能性があるため、静的または動的のいずれかと見なされます。  
* Full static configuration
  * サーバーはすべてのクライアントを認識し、クライアントはサーバーを認識しているため、サービス検出はまったく必要ありません。
* No discovery by application code
  * クライアントはサーバーを知っていますが、サーバーはクライアントを知りません。イベントサブスクリプションは、アプリケーションの唯一の動的通信パターンです。
* Full service discovery in the application
  * 構成時に通信パスは不明です。サービス検出用のAPIを使用すると、アプリケーションコードは実行時にサービスインスタンスを選択できます。

### 8.6 Service Contract Versioning
SOA環境では、サービスのクライアントとプロバイダーは、サービスのインターフェースと動作をカバーするコントラクトに依存しています。  
サービスの開発中に、サービスインターフェイスまたは動作が時間の経過とともに変化する場合があります。そのため、サービスの異なるバージョンを区別するために、サービス契約のバージョン管理が導入されました。 AUTOSAR Adaptiveプラットフォームは、サービスの設計および展開フェーズのコントラクトバージョニングをサポートします。さらに、クライアントのサービスディスカバリは、バージョンの後方互換性をサポートするように構成できます。これは、提供されているさまざまなサービスバージョンが、クライアントの必要なサービスバージョンと下位互換性がある場合、それらに接続できることを意味します。

### 8.7 Raw Data Streaming interface
サービス指向通信に加えて、CMは、外部ECUに向けて生のバイナリデータストリームを処理するためのスタンドアロンAPIも提供します。 例えば、ADASシステムのセンサー。 APIは静的であり、クライアントアプリケーションがサーバーへの通信チャネルを確立し、サーバーアプリケーションがクライアントからの着信接続を待機する機能を実装します。 APIは、クライアントとサーバーの両方に機能を提供し、通信チャネルを破棄し、通信チャネルを介して生データ（バイトのストリーム）を読み書きします。 Raw Data Streamチャネルは、インテグレーターが展開情報を適用することで構成できます。ネットワークエンドポイント情報と選択されたプロトコル。現在、TCP / IPソケットはトランスポート層として使用されますが、将来的には他の代替手段が追加される可能性があります。 Raw Data Streamインターフェースは、名前空間ara :: com :: rawで使用できます。


### 18.1.4 Future and Promise
ara :: core :: Resultが同期関数呼び出しの一般化された戻り型として使用されるのと同様に、ara :: core :: Futureは非同期関数呼び出しの一般化された戻り型として使用されます。  

ara :: core :: Futureはstd :: futureに厳密にモデル化されていますが、ara :: core :: Resultと相互運用するように拡張されています。  

ara :: core :: Resultと同様に、ara :: core :: Futureは、値またはエラーのいずれかを含むクラスです。  
このコンテンツは、次の2つの方法で抽出できます。  
1. ara :: core :: Future :: getを呼び出すことにより、含まれている値が存在する場合はそれを返し、存在しない場合は例外をスローします。  
2. ara :: core :: Future :: GetResultを呼び出すことにより、Futureからの値またはエラーを含むara :: core :: Resultオブジェクトを返します。  

これらの呼び出しは両方とも、非同期関数呼び出しによって値またはエラーが使用可能になるまでブロックされます。